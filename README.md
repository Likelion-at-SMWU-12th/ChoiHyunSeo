# 🖼️ 디자인 패턴

<aside>
💡

소프트웨어 개발에서 발생하는 일반적, 반복적인 문제 해결에 대해 검증된 구조적 솔루션
즉, ***이해하고 유지 관리하기 쉬운 방식으로 코드를 구조화하고 재사용하는 방법***

</aside>

> 디자인 패턴을 통해 팀이 일관된 방식으로 소프트웨어를 설계, 관리하고 이해
→ 소프트웨어 개발에 대해 소통할 수 있는 ‘**공통** **어휘**’
> 

# 💬 FLUX

## ✔️ 등장배경

<aside>
💡

**MVC?**

</aside>

> **Model**
→ 앱이 포함해야할 데이터가 무엇인지를 정의
> 

> **View**
→ 데이터를 보여주는 방식을 정의
> 
> 
> ex. HTML, CSS로 그려지는 화면
> 

> **Controller**
> 
> 
> → 데이터를 받아서 화면을 바꾸고 이벤트를 처리, 서버에 데이터를 전달
> 
> ex. Javascript
> 

## ✔️ 기존 MVC 패턴의 한계

한 Model이 업데이트 되면 그에 따라 View가 업데이트 되고, 업데이트된 View는 또 다른 Model을 업데이트하는 식의
양방향 데이터 흐름을 가질 수 있음.

Model의 개수가 많아질수록 각 Model에서 발생한 이벤트가 퍼져나갈 때 이를 예측하기 힘들어짐.
MVC패턴에서의 데이터 흐름
Model과 View가 서로의 변화를 감지하고 반응
모델이 새로운 데이터를 얻거나 변경되면
변화를 뷰가 갱신된 정보를 표시

➡️ 모델에서 뷰로 데이터가 흐름

뷰에서 사용자가 새로운 데이터를 입력하면
컨트롤러를 통해 모델에 반영

➡️ 뷰에서 모델로 데이터가 흐름
이러한 MVC 패턴의 복잡성을 해소하기 위해 FLUX 패턴이 등장

## ✔️ FLUX 패턴

> **데이터 흐름의 일관성과 예측 가능성을 유지하기 위해 사용하는 데이터 바인딩 패턴**
> 
- 리액트는 부모에서 자식으로 데이터가 흐르는 ***단방향 데이터 흐름을 따름***.
- 이 때문에 컴포넌트 구조가 복잡해지면 특정 값을 전달하기 위해,
중간 레벨 컴포넌트들이 전부 그 props를 가지고 있어야 하는 ***props drilling 문제가 발생***함.
- 이를 해결하기 위해 컴포넌트 간의 데이터 흐름을 더 명확하게 하고, 
데이터가 한 곳에서만 관리돼야 할 필요가 있었기 때문에 ***한 방향으로만 데이터가 흐르는 FLUX 패턴***

<aside>
💡

**데이터 바인딩 패턴?**

</aside>

- UI 요소와 데이터 모델을 연결하는 기법
- 두 요소 간의 상호작용을 관리하고 데이터 변화를 UI에 자동으로 반영하는 패턴

### 구성 및 작동방식

> **Action**
데이터 변경과 요청에 대한 정보를 담은 객체
> 

> **Dispatcher**
Action을 받아 각 Action에 따라 콜백 함수를 실행(Action을 처리)하여 Store에 전달
> 

> **Store**
데이터의 중앙 저장소, Action의 결과로 데이터를 업데이트
> 

> **View**
Store에서 데이터를 가져와 UI를 업데이트
자식의 View로 데이터를 흘려 보내는 View Controller 역할도 같이함
> 

> **작동방식**
View에서 Action 발생 ➡ Dispatcher가 Action을 Store에 전달 
➡ Store에서 데이터 업데이트 ➡ View에서 변경된 데이터 반영
> 

# 💤 Zustand

<aside>
💡

**React 프로젝트에서 사용하는 작고 빠르며 확장 가능한 상태 관리(Store) 라이브러리**

</aside>

- store 개념을 사용하여 상태를 관리함
- 하나의 중앙에 집중된 스토어 구조를 활용
- 특정 라이브러리에 엮이지 않음
- 상태 변경 시 불필요한 리렌더링이 불필요
- 핵심 로직 코드 수가 적어, 동작을 위해 알아야하는 코드 양이 굉장히 적음

## ❓ Store란?

<aside>
💡

애플리케이션의 **여러 상태(State)**를 하는 **중앙에서 관리**하는 패턴

> **스토어
상태(state)와 액션(action)을 포함하는 객체**로, 상태와 액션을 정의해주는 것은 **`create 함수`**
> 
</aside>

## ✏️ 문법

→ 자세한 건 강의 자료 확인하기

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/e6fa8f03-79ab-4c3e-98cf-c3cfdfd58f17/e0453771-bd95-46fc-82ba-c35c5fb18bb1/image.png)

### set 함수

- 상태 업데이트에 사용
- 현재 상태를 기반으로 새로운 상태 설정

### get 함수

- 현재 상태를 가져오는 데 사용
- 상태를 읽을 수 있도록 도와주며, 이를 통해 상태에 접근하거나 이를 이용해 추가 작업을 수행

# 🆚 context api vs zustand

## Context Api

<aside>
💡

**전역 상태 관리가 필요한 소규모 애플리케이션에 적합
라이브러리를 추가로 설치할 필요가 없어 간단한 용도**

</aside>

- 컴포넌트 트리 전반에 걸쳐 데이터를 전달할 때, 일일이 props를 내려주지 않고 전역으로 상태를 관리 가능
- React에서 전역적으로 데이터를 공유하기 위해 사용되지만 **전역상태관리도구는 아님**
- 불필요한 리렌더링이 발생함 → `useContext` 훅을 사용하기 때문 (하위 컴포넌트가 리렌더링 → 성능저하)

## Zustand

<aside>
💡

**성능이 중요하거나 상태 변화가 자주 발생하는 복잡한 애플리케이션
성능 최적화와 상태 관리의 유연성**

</aside>

- 상태 관리 라이브러리 → 필요한 부분만 구독하여 리렌더링 문제를 최적화
- 특정 컴포넌트가 상태 변화에만 반응하게 만들 수 있음
- 성능 측면에서 매우 효율적이고,  React와의 의존성을 최소화 → 상태 관리를 더욱 유연하게 할 수 있음
